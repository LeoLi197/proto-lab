# .github/workflows/deploy.yml
name: Deploy flashmvp to Cloudflare and GCP

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'

jobs:
  # Job 1: 部署后端到 Google Cloud Run
  deploy-backend:
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'

    outputs:
      backend_url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load Project Configuration
        id: config
        working-directory: ./deployment/setup
        run: |
          if [ ! -f ./config.sh ]; then
            echo "::error file=config.sh::Configuration file deployment/setup/config.sh not found."
            exit 1
          fi
          source ./config.sh
          echo "gcp_region=${GCP_REGION}" >> $GITHUB_OUTPUT
          echo "backend_service=${PROJECT_NAME_BASE}-backend" >> $GITHUB_OUTPUT
          echo "gcp_project_id=${GCP_PROJECT_ID}" >> $GITHUB_OUTPUT

      # ==============================================================================
      # [新增] 部署前依赖检查 - 提前发现问题
      # ------------------------------------------------------------------------------
      # 在构建 Docker 镜像前检查关键文件和依赖配置
      # ==============================================================================
      - name: Pre-deployment Validation
        run: |
          echo "🔍 检查关键文件..."
          
          # 检查 requirements.txt
          if [ ! -f ./backend/requirements.txt ]; then
            echo "::error::backend/requirements.txt 不存在"
            exit 1
          fi
          
          # 检查关键依赖是否存在且未被注释
          echo "检查关键依赖..."
          if ! grep -v "^#" ./backend/requirements.txt | grep -q "python-multipart"; then
            echo "::error::python-multipart 依赖缺失或被注释，这会导致文件上传功能失败"
            exit 1
          fi
          
          # ==============================================================================
          # [示例] 如何添加您自己功能的关键依赖检查
          # ------------------------------------------------------------------------------
          # 如果您的新功能依赖某个关键库, 可以在这里添加检查, 避免部署失败。
          #
          # if ! grep -v "^#" ./backend/requirements.txt | grep -q "my-critical-library"; then
          #   echo "::error::my-critical-library 依赖缺失或被注释"  
          #   exit 1
          # fi
          # ==============================================================================
          #
          # --- [已移除功能的依赖检查示例] ---
          # if ! grep -v "^#" ./backend/requirements.txt | grep -q "PyMuPDF"; then
          #   echo "::error::PyMuPDF 依赖缺失或被注释，这会导致PDF处理功能失败"  
          #   exit 1
          # fi
          
          echo "✅ 依赖检查通过"
          
          echo "✅ 模块结构检查通过"

      - name: Authenticate to Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'
  
      - name: Deploy Backend to Cloud Run via gcloud CLI
        id: deploy
        run: |
          echo "🚀 开始部署后端到 Cloud Run..."
          
          # ==============================================================================
          # [最终修复] 从GitHub Secrets安全地注入所有环境变量
          # - GEMINI_API_KEY_PAID 增加备用逻辑，如果未设置则使用免费版密钥，确保服务稳定
          # ==============================================================================
          SERVICE_URL=$(gcloud run deploy ${{ steps.config.outputs.backend_service }} \
            --source=./backend \
            --project=${{ steps.config.outputs.gcp_project_id }} \
            --region=${{ steps.config.outputs.gcp_region }} \
            --memory=2Gi \
            --cpu=1 \
            --timeout=300 \
            --concurrency=100 \
            --max-instances=10 \
            --set-env-vars="PYTHONPATH=/app,PYTHONDONTWRITEBYTECODE=1,PYTHONUNBUFFERED=1,GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }},GEMINI_API_KEY_PAID=${{ secrets.GEMINI_API_KEY_PAID || secrets.GEMINI_API_KEY }}" \
            --format="value(status.url)" \
            --verbosity=debug \
            --quiet)
          
          if [ -z "$SERVICE_URL" ]; then
            echo "::error::Failed to retrieve service URL after deployment."
            
            # 获取最新的部署日志来帮助调试
            echo "🔍 获取部署失败的详细日志..."
            gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=${{ steps.config.outputs.backend_service }}" \
              --project=${{ steps.config.outputs.gcp_project_id }} \
              --limit=50 \
              --format="table(timestamp,severity,textPayload)" \
              --freshness=10m || true
            
            exit 1
          fi
          
          echo "✅ 部署成功! URL: $SERVICE_URL"
          echo "url=${SERVICE_URL}" >> $GITHUB_OUTPUT

      - name: Allow unauthenticated invocations
        run: |
          gcloud run services add-iam-policy-binding ${{ steps.config.outputs.backend_service }} \
            --project=${{ steps.config.outputs.gcp_project_id }} \
            --region=${{ steps.config.outputs.gcp_region }} \
            --member="allUsers" \
            --role="roles/run.invoker" \
            --quiet

      # ==============================================================================
      # [新增] 部署后健康检查 - 确保服务正常启动
      # ------------------------------------------------------------------------------
      # 在继续前端部署前确保后端服务已成功启动
      # ==============================================================================
      - name: Backend Health Check
        run: |
          echo "🏥 执行后端健康检查..."
          
          BACKEND_URL="${{ steps.deploy.outputs.url }}"
          MAX_ATTEMPTS=10
          WAIT_TIME=30
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "尝试 $i/$MAX_ATTEMPTS: 检查 $BACKEND_URL"
            
            # 首先检查根路径
            if curl -f -s --max-time 30 "$BACKEND_URL" > /dev/null; then
              echo "✅ 后端根路径响应正常"
              
              # 然后检查健康检查端点（如果存在）
              if curl -f -s --max-time 30 "$BACKEND_URL/api/health" > /dev/null; then
                echo "✅ 后端健康检查端点响应正常"
              else
                echo "⚠️  健康检查端点无响应，但根路径正常"
              fi
              
              break
            else
              echo "❌ 尝试 $i 失败，等待 ${WAIT_TIME}s..."
              
              if [ $i -eq $MAX_ATTEMPTS ]; then
                echo "::error::后端健康检查失败，获取日志进行调试..."
                
                # 输出服务状态
                gcloud run services describe ${{ steps.config.outputs.backend_service }} \
                  --project=${{ steps.config.outputs.gcp_project_id }} \
                  --region=${{ steps.config.outputs.gcp_region }} \
                  --format="table(status.conditions[].type,status.conditions[].status,status.conditions[].message)" || true
                
                # 输出最近的日志
                gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=${{ steps.config.outputs.backend_service }}" \
                  --project=${{ steps.config.outputs.gcp_project_id }} \
                  --limit=20 \
                  --format="table(timestamp,severity,textPayload)" \
                  --freshness=5m || true
                
                exit 1
              fi
              
              sleep $WAIT_TIME
            fi
          done

      - name: Display Backend URL
        run: |
          echo "✅ 后端部署完成！"
          echo "Backend URL: ${{ steps.deploy.outputs.url }}"

  # Job 2: 部署前端到 Cloudflare Pages
  deploy-frontend:
    runs-on: ubuntu-latest
    needs: deploy-backend 
    
    env:
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Wrangler
        run: npm install -g wrangler
          
      - name: Create D1 Database if not exists
        working-directory: ./frontend
        run: |
          if ! wrangler d1 info ${{ secrets.CF_D1_DATABASE_NAME }}; then
            echo "Creating D1 Database..."
            wrangler d1 create ${{ secrets.CF_D1_DATABASE_NAME }}
          else
            echo "D1 Database already exists."
          fi

      - name: Get D1 Database ID
        id: d1_info
        working-directory: ./frontend
        run: |
          DB_UUID=$(wrangler d1 info ${{ secrets.CF_D1_DATABASE_NAME }} --json | grep -o '"uuid": *"[^"]*"' | grep -o '"[^"]*"$' | tr -d '"')
          echo "database_id=$DB_UUID" >> $GITHUB_OUTPUT

      - name: Dynamically Configure All Bindings in wrangler.toml
        working-directory: ./frontend
        run: |
          # 先删除旧 [vars] 和 [[d1_databases]] 段
          awk '
            BEGIN{drop=0}
            /^\[vars\]/{drop=1}
            /^\[\[d1_databases\]\]/{drop=1}
            /^\[.*\]$/ && drop==1 && $0!~/^\[vars\]$/ && $0!~/^\[\[d1_databases\]\]$/{drop=0}
            drop==0{print}
          ' wrangler.toml > wrangler.clean.toml
          mv wrangler.clean.toml wrangler.toml
          
          cat << EOF >> wrangler.toml

          # Dynamically added by CI
          [vars]
          BACKEND_URL = "${{ needs.deploy-backend.outputs.backend_url }}"

          [[d1_databases]]
          binding = "DB"
          database_name = "${{ secrets.CF_D1_DATABASE_NAME }}"
          database_id = "${{ steps.d1_info.outputs.database_id }}"
          EOF

      - name: Apply D1 Schema
        working-directory: ./frontend
        run: |
          wrangler d1 execute ${{ secrets.CF_D1_DATABASE_NAME }} --file=./schema.sql

      # === 修改点 #1：Pages 部署（A优先：prod/main；失败自动 B：preview）===
      - name: Deploy frontend (prod-first with fallback)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CF_PAGES_PROJECT_NAME: ${{ secrets.CF_PAGES_PROJECT_NAME }}
        run: |
          set +e  # 允许命令失败以便处理回退逻辑
          PROJECT="$CF_PAGES_PROJECT_NAME"

          echo "🚀 尝试部署到生产分支 'main' (方案A)..."
          npx wrangler pages deploy ./frontend --project-name "$PROJECT" --branch main --commit-dirty=true 2>&1
          
          if [ $? -eq 0 ]; then
            PROD_URL="https://${PROJECT}.pages.dev"
            echo "DEPLOY_MODE=production" >> $GITHUB_ENV
            echo "FRONTEND_URL=$PROD_URL" >> $GITHUB_ENV
            echo "✅ 生产部署成功! URL: $PROD_URL"
          else
            echo "⚠️ 生产部署失败，切换到预览部署 (方案B)..."
            
            # 尝试预览部署并捕获输出
            DEPLOY_OUTPUT=$(npx wrangler pages deploy ./frontend --project-name "$PROJECT" --commit-dirty=true 2>&1)
            echo "$DEPLOY_OUTPUT"
            
            # 从输出中提取预览URL
            PREVIEW_URL=$(echo "$DEPLOY_OUTPUT" | grep -oE "https://[a-z0-9-]+\.${PROJECT}\.pages\.dev" | head -n1)
            
            if [ -z "$PREVIEW_URL" ]; then
              echo "从部署列表获取最新预览URL..."
              # 确保安装jq
              command -v jq >/dev/null 2>&1 || (sudo apt-get update && sudo apt-get install -y jq)
              PREVIEW_URL=$(npx wrangler pages deployments list --project-name "$PROJECT" --json \
                | jq -r '[.[] | select(.environment=="preview")] | sort_by(.created_on) | last | .url')
            fi
            
            if [ -z "$PREVIEW_URL" ]; then
              echo "::error::无法确定预览URL"
              exit 1
            fi
            
            echo "DEPLOY_MODE=preview" >> $GITHUB_ENV
            echo "FRONTEND_URL=$PREVIEW_URL" >> $GITHUB_ENV
            echo "✅ 预览部署成功! URL: $PREVIEW_URL"
          fi
      
      - name: Force Set BACKEND_URL via Cloudflare API
        run: |
          echo "Forcing environment variable update via Cloudflare API to ensure availability..."
          curl -X PATCH "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/${{ secrets.CF_PAGES_PROJECT_NAME }}" \
          -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -H "Content-Type: application/json" \
          --data '{
            "deployment_configs": {
              "production": {
                "env_vars": {
                  "BACKEND_URL": {
                    "value": "${{ needs.deploy-backend.outputs.backend_url }}"
                  }
                }
              }
            }
          }'
      
      - name: Trigger Redeployment to Apply Environment Variables
        id: trigger_redeploy
        run: |
          echo "Triggering a new deployment to ensure all variables are applied..."
          curl -X POST "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/${{ secrets.CF_PAGES_PROJECT_NAME }}/deployments" \
          -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -H "Content-Type: application/json"

  # Job 3: 验证部署
  verify-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Install Tools
        run: |
          npm install -g wrangler
          command -v jq >/dev/null 2>&1 || (sudo apt-get update && sudo apt-get install -y jq)
      
      - name: Health Check Backend
        env:
          BACKEND_URL: ${{ needs.deploy-backend.outputs.backend_url }}
        run: |
          echo "Verifying backend at $BACKEND_URL with retries..."
          for i in $(seq 1 5); do
            curl -f "$BACKEND_URL" && break || sleep 10
          done
          
      # === 修改点 #2：前端验证（A优先：prod；失败自动 B：preview）===
      - name: Verify frontend (prod-first, auto-fallback to preview)
        env:
          CF_PAGES_PROJECT_NAME: ${{ secrets.CF_PAGES_PROJECT_NAME }}
          FRONTEND_HEALTH_PATH: /index.html
        run: |
          set -e
          tries=24   # 最多尝试 24 次
          wait=10    # 每次等待 10 秒
          ok=""
          
          # 首先尝试生产域名
          URL="https://${CF_PAGES_PROJECT_NAME}.pages.dev"
          
          echo "🔍 验证生产环境 $URL$FRONTEND_HEALTH_PATH (最多 $tries 次尝试)..."
          for i in $(seq 1 $tries); do
            code=$(curl -sS -L -o /dev/null -w "%{http_code}" "$URL$FRONTEND_HEALTH_PATH" || echo "000")
            if echo "$code" | grep -qE "^(20|30)"; then
              ok="yes"
              echo "✅ 生产环境健康 (状态码: $code)"
              echo "VERIFIED_URL=$URL" >> $GITHUB_ENV
              break
            fi
            echo "尝试 $i 返回状态码 $code; ${wait}秒后重试..."
            sleep $wait
          done
          
          # 如果生产环境失败，尝试预览环境
          if [ -z "$ok" ]; then
            echo "⚠️ 生产环境检查失败，尝试最新的预览部署..."
            
            # 获取最新的预览URL
            PREVIEW_URL=$(npx wrangler pages deployments list --project-name "$CF_PAGES_PROJECT_NAME" --json \
              | jq -r '[.[] | select(.environment=="preview")] | sort_by(.created_on) | last | .url')
            
            if [ -n "$PREVIEW_URL" ]; then
              URL="$PREVIEW_URL"
              echo "🔍 验证预览环境 $URL$FRONTEND_HEALTH_PATH..."
              
              for i in $(seq 1 $tries); do
                code=$(curl -sS -L -o /dev/null -w "%{http_code}" "$URL$FRONTEND_HEALTH_PATH" || echo "000")
                if echo "$code" | grep -qE "^(20|30)"; then
                  ok="yes"
                  echo "✅ 预览环境健康 (状态码: $code)"
                  echo "VERIFIED_URL=$URL" >> $GITHUB_ENV
                  break
                fi
                echo "预览尝试 $i 返回状态码 $code; ${wait}秒后重试..."
                sleep $wait
              done
            else
              echo "::error::未找到预览部署"
            fi
          fi
          
          if [ -z "$ok" ]; then
            echo "::error::前端健康检查失败 (A方案和B方案都失败)"
            exit 1
          fi

      - name: Output verified URL
        if: ${{ success() }}
        run: |
          echo "✅ 部署验证成功!"
          echo "最终验证的URL: ${{ env.VERIFIED_URL }}"
          