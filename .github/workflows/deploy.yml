# .github/workflows/deploy.yml
name: Deploy flashmvp to Cloudflare and GCP

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'

jobs:
  # Job 1: éƒ¨ç½²åç«¯åˆ° Google Cloud Run
  deploy-backend:
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'

    outputs:
      backend_url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load Project Configuration
        id: config
        working-directory: ./deployment/setup
        run: |
          if [ ! -f ./config.sh ]; then
            echo "::error file=config.sh::Configuration file deployment/setup/config.sh not found."
            exit 1
          fi
          source ./config.sh
          echo "gcp_region=${GCP_REGION}" >> $GITHUB_OUTPUT
          echo "backend_service=${PROJECT_NAME_BASE}-backend" >> $GITHUB_OUTPUT
          echo "gcp_project_id=${GCP_PROJECT_ID}" >> $GITHUB_OUTPUT

      # ==============================================================================
      # [æ–°å¢] éƒ¨ç½²å‰ä¾èµ–æ£€æŸ¥ - æå‰å‘ç°é—®é¢˜
      # ------------------------------------------------------------------------------
      # åœ¨æ„å»º Docker é•œåƒå‰æ£€æŸ¥å…³é”®æ–‡ä»¶å’Œä¾èµ–é…ç½®
      # ==============================================================================
      - name: Pre-deployment Validation
        run: |
          echo "ğŸ” æ£€æŸ¥å…³é”®æ–‡ä»¶..."
          
          # æ£€æŸ¥ requirements.txt
          if [ ! -f ./backend/requirements.txt ]; then
            echo "::error::backend/requirements.txt ä¸å­˜åœ¨"
            exit 1
          fi
          
          # æ£€æŸ¥å…³é”®ä¾èµ–æ˜¯å¦å­˜åœ¨ä¸”æœªè¢«æ³¨é‡Š
          echo "æ£€æŸ¥å…³é”®ä¾èµ–..."
          if ! grep -v "^#" ./backend/requirements.txt | grep -q "python-multipart"; then
            echo "::error::python-multipart ä¾èµ–ç¼ºå¤±æˆ–è¢«æ³¨é‡Šï¼Œè¿™ä¼šå¯¼è‡´æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½å¤±è´¥"
            exit 1
          fi
          
          # ==============================================================================
          # [ç¤ºä¾‹] å¦‚ä½•æ·»åŠ æ‚¨è‡ªå·±åŠŸèƒ½çš„å…³é”®ä¾èµ–æ£€æŸ¥
          # ------------------------------------------------------------------------------
          # å¦‚æœæ‚¨çš„æ–°åŠŸèƒ½ä¾èµ–æŸä¸ªå…³é”®åº“, å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ£€æŸ¥, é¿å…éƒ¨ç½²å¤±è´¥ã€‚
          #
          # if ! grep -v "^#" ./backend/requirements.txt | grep -q "my-critical-library"; then
          #   echo "::error::my-critical-library ä¾èµ–ç¼ºå¤±æˆ–è¢«æ³¨é‡Š"  
          #   exit 1
          # fi
          # ==============================================================================
          #
          # --- [å·²ç§»é™¤åŠŸèƒ½çš„ä¾èµ–æ£€æŸ¥ç¤ºä¾‹] ---
          # if ! grep -v "^#" ./backend/requirements.txt | grep -q "PyMuPDF"; then
          #   echo "::error::PyMuPDF ä¾èµ–ç¼ºå¤±æˆ–è¢«æ³¨é‡Šï¼Œè¿™ä¼šå¯¼è‡´PDFå¤„ç†åŠŸèƒ½å¤±è´¥"  
          #   exit 1
          # fi
          
          echo "âœ… ä¾èµ–æ£€æŸ¥é€šè¿‡"
          
          echo "âœ… æ¨¡å—ç»“æ„æ£€æŸ¥é€šè¿‡"

      - name: Authenticate to Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'
  
      - name: Deploy Backend to Cloud Run via gcloud CLI
        id: deploy
        run: |
          echo "ğŸš€ å¼€å§‹éƒ¨ç½²åç«¯åˆ° Cloud Run..."
          
          # ==============================================================================
          # [æœ€ç»ˆä¿®å¤] ä»GitHub Secretså®‰å…¨åœ°æ³¨å…¥æ‰€æœ‰ç¯å¢ƒå˜é‡
          # - GEMINI_API_KEY_PAID å¢åŠ å¤‡ç”¨é€»è¾‘ï¼Œå¦‚æœæœªè®¾ç½®åˆ™ä½¿ç”¨å…è´¹ç‰ˆå¯†é’¥ï¼Œç¡®ä¿æœåŠ¡ç¨³å®š
          # ==============================================================================
          SERVICE_URL=$(gcloud run deploy ${{ steps.config.outputs.backend_service }} \
            --source=./backend \
            --project=${{ steps.config.outputs.gcp_project_id }} \
            --region=${{ steps.config.outputs.gcp_region }} \
            --memory=2Gi \
            --cpu=1 \
            --timeout=300 \
            --concurrency=100 \
            --max-instances=10 \
            --set-env-vars="PYTHONPATH=/app,PYTHONDONTWRITEBYTECODE=1,PYTHONUNBUFFERED=1,GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }},GEMINI_API_KEY_PAID=${{ secrets.GEMINI_API_KEY_PAID || secrets.GEMINI_API_KEY }}" \
            --format="value(status.url)" \
            --verbosity=debug \
            --quiet)
          
          if [ -z "$SERVICE_URL" ]; then
            echo "::error::Failed to retrieve service URL after deployment."
            
            # è·å–æœ€æ–°çš„éƒ¨ç½²æ—¥å¿—æ¥å¸®åŠ©è°ƒè¯•
            echo "ğŸ” è·å–éƒ¨ç½²å¤±è´¥çš„è¯¦ç»†æ—¥å¿—..."
            gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=${{ steps.config.outputs.backend_service }}" \
              --project=${{ steps.config.outputs.gcp_project_id }} \
              --limit=50 \
              --format="table(timestamp,severity,textPayload)" \
              --freshness=10m || true
            
            exit 1
          fi
          
          echo "âœ… éƒ¨ç½²æˆåŠŸ! URL: $SERVICE_URL"
          echo "url=${SERVICE_URL}" >> $GITHUB_OUTPUT

      - name: Allow unauthenticated invocations
        run: |
          gcloud run services add-iam-policy-binding ${{ steps.config.outputs.backend_service }} \
            --project=${{ steps.config.outputs.gcp_project_id }} \
            --region=${{ steps.config.outputs.gcp_region }} \
            --member="allUsers" \
            --role="roles/run.invoker" \
            --quiet

      # ==============================================================================
      # [æ–°å¢] éƒ¨ç½²åå¥åº·æ£€æŸ¥ - ç¡®ä¿æœåŠ¡æ­£å¸¸å¯åŠ¨
      # ------------------------------------------------------------------------------
      # åœ¨ç»§ç»­å‰ç«¯éƒ¨ç½²å‰ç¡®ä¿åç«¯æœåŠ¡å·²æˆåŠŸå¯åŠ¨
      # ==============================================================================
      - name: Backend Health Check
        run: |
          echo "ğŸ¥ æ‰§è¡Œåç«¯å¥åº·æ£€æŸ¥..."
          
          BACKEND_URL="${{ steps.deploy.outputs.url }}"
          MAX_ATTEMPTS=10
          WAIT_TIME=30
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "å°è¯• $i/$MAX_ATTEMPTS: æ£€æŸ¥ $BACKEND_URL"
            
            # é¦–å…ˆæ£€æŸ¥æ ¹è·¯å¾„
            if curl -f -s --max-time 30 "$BACKEND_URL" > /dev/null; then
              echo "âœ… åç«¯æ ¹è·¯å¾„å“åº”æ­£å¸¸"
              
              # ç„¶åæ£€æŸ¥å¥åº·æ£€æŸ¥ç«¯ç‚¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
              if curl -f -s --max-time 30 "$BACKEND_URL/api/health" > /dev/null; then
                echo "âœ… åç«¯å¥åº·æ£€æŸ¥ç«¯ç‚¹å“åº”æ­£å¸¸"
              else
                echo "âš ï¸  å¥åº·æ£€æŸ¥ç«¯ç‚¹æ— å“åº”ï¼Œä½†æ ¹è·¯å¾„æ­£å¸¸"
              fi
              
              break
            else
              echo "âŒ å°è¯• $i å¤±è´¥ï¼Œç­‰å¾… ${WAIT_TIME}s..."
              
              if [ $i -eq $MAX_ATTEMPTS ]; then
                echo "::error::åç«¯å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œè·å–æ—¥å¿—è¿›è¡Œè°ƒè¯•..."
                
                # è¾“å‡ºæœåŠ¡çŠ¶æ€
                gcloud run services describe ${{ steps.config.outputs.backend_service }} \
                  --project=${{ steps.config.outputs.gcp_project_id }} \
                  --region=${{ steps.config.outputs.gcp_region }} \
                  --format="table(status.conditions[].type,status.conditions[].status,status.conditions[].message)" || true
                
                # è¾“å‡ºæœ€è¿‘çš„æ—¥å¿—
                gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=${{ steps.config.outputs.backend_service }}" \
                  --project=${{ steps.config.outputs.gcp_project_id }} \
                  --limit=20 \
                  --format="table(timestamp,severity,textPayload)" \
                  --freshness=5m || true
                
                exit 1
              fi
              
              sleep $WAIT_TIME
            fi
          done

      - name: Display Backend URL
        run: |
          echo "âœ… åç«¯éƒ¨ç½²å®Œæˆï¼"
          echo "Backend URL: ${{ steps.deploy.outputs.url }}"

  # Job 2: éƒ¨ç½²å‰ç«¯åˆ° Cloudflare Pages
  deploy-frontend:
    runs-on: ubuntu-latest
    needs: deploy-backend 
    
    env:
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Wrangler
        run: npm install -g wrangler
          
      - name: Create D1 Database if not exists
        working-directory: ./frontend
        run: |
          if ! wrangler d1 info ${{ secrets.CF_D1_DATABASE_NAME }}; then
            echo "Creating D1 Database..."
            wrangler d1 create ${{ secrets.CF_D1_DATABASE_NAME }}
          else
            echo "D1 Database already exists."
          fi

      - name: Get D1 Database ID
        id: d1_info
        working-directory: ./frontend
        run: |
          DB_UUID=$(wrangler d1 info ${{ secrets.CF_D1_DATABASE_NAME }} --json | grep -o '"uuid": *"[^"]*"' | grep -o '"[^"]*"$' | tr -d '"')
          echo "database_id=$DB_UUID" >> $GITHUB_OUTPUT

      - name: Dynamically Configure All Bindings in wrangler.toml
        working-directory: ./frontend
        run: |
          # å…ˆåˆ é™¤æ—§ [vars] å’Œ [[d1_databases]] æ®µ
          awk '
            BEGIN{drop=0}
            /^\[vars\]/{drop=1}
            /^\[\[d1_databases\]\]/{drop=1}
            /^\[.*\]$/ && drop==1 && $0!~/^\[vars\]$/ && $0!~/^\[\[d1_databases\]\]$/{drop=0}
            drop==0{print}
          ' wrangler.toml > wrangler.clean.toml
          mv wrangler.clean.toml wrangler.toml
          
          cat << EOF >> wrangler.toml

          # Dynamically added by CI
          [vars]
          BACKEND_URL = "${{ needs.deploy-backend.outputs.backend_url }}"

          [[d1_databases]]
          binding = "DB"
          database_name = "${{ secrets.CF_D1_DATABASE_NAME }}"
          database_id = "${{ steps.d1_info.outputs.database_id }}"
          EOF

      - name: Apply D1 Schema
        working-directory: ./frontend
        run: |
          wrangler d1 execute ${{ secrets.CF_D1_DATABASE_NAME }} --file=./schema.sql

      # === ä¿®æ”¹ç‚¹ #1ï¼šPages éƒ¨ç½²ï¼ˆAä¼˜å…ˆï¼šprod/mainï¼›å¤±è´¥è‡ªåŠ¨ Bï¼špreviewï¼‰===
      - name: Deploy frontend (prod-first with fallback)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CF_PAGES_PROJECT_NAME: ${{ secrets.CF_PAGES_PROJECT_NAME }}
        run: |
          set +e  # å…è®¸å‘½ä»¤å¤±è´¥ä»¥ä¾¿å¤„ç†å›é€€é€»è¾‘
          PROJECT="$CF_PAGES_PROJECT_NAME"

          echo "ğŸš€ å°è¯•éƒ¨ç½²åˆ°ç”Ÿäº§åˆ†æ”¯ 'main' (æ–¹æ¡ˆA)..."
          npx wrangler pages deploy ./frontend --project-name "$PROJECT" --branch main --commit-dirty=true 2>&1
          
          if [ $? -eq 0 ]; then
            PROD_URL="https://${PROJECT}.pages.dev"
            echo "DEPLOY_MODE=production" >> $GITHUB_ENV
            echo "FRONTEND_URL=$PROD_URL" >> $GITHUB_ENV
            echo "âœ… ç”Ÿäº§éƒ¨ç½²æˆåŠŸ! URL: $PROD_URL"
          else
            echo "âš ï¸ ç”Ÿäº§éƒ¨ç½²å¤±è´¥ï¼Œåˆ‡æ¢åˆ°é¢„è§ˆéƒ¨ç½² (æ–¹æ¡ˆB)..."
            
            # å°è¯•é¢„è§ˆéƒ¨ç½²å¹¶æ•è·è¾“å‡º
            DEPLOY_OUTPUT=$(npx wrangler pages deploy ./frontend --project-name "$PROJECT" --commit-dirty=true 2>&1)
            echo "$DEPLOY_OUTPUT"
            
            # ä»è¾“å‡ºä¸­æå–é¢„è§ˆURL
            PREVIEW_URL=$(echo "$DEPLOY_OUTPUT" | grep -oE "https://[a-z0-9-]+\.${PROJECT}\.pages\.dev" | head -n1)
            
            if [ -z "$PREVIEW_URL" ]; then
              echo "ä»éƒ¨ç½²åˆ—è¡¨è·å–æœ€æ–°é¢„è§ˆURL..."
              # ç¡®ä¿å®‰è£…jq
              command -v jq >/dev/null 2>&1 || (sudo apt-get update && sudo apt-get install -y jq)
              PREVIEW_URL=$(npx wrangler pages deployments list --project-name "$PROJECT" --json \
                | jq -r '[.[] | select(.environment=="preview")] | sort_by(.created_on) | last | .url')
            fi
            
            if [ -z "$PREVIEW_URL" ]; then
              echo "::error::æ— æ³•ç¡®å®šé¢„è§ˆURL"
              exit 1
            fi
            
            echo "DEPLOY_MODE=preview" >> $GITHUB_ENV
            echo "FRONTEND_URL=$PREVIEW_URL" >> $GITHUB_ENV
            echo "âœ… é¢„è§ˆéƒ¨ç½²æˆåŠŸ! URL: $PREVIEW_URL"
          fi
      
      - name: Force Set BACKEND_URL via Cloudflare API
        run: |
          echo "Forcing environment variable update via Cloudflare API to ensure availability..."
          curl -X PATCH "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/${{ secrets.CF_PAGES_PROJECT_NAME }}" \
          -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -H "Content-Type: application/json" \
          --data '{
            "deployment_configs": {
              "production": {
                "env_vars": {
                  "BACKEND_URL": {
                    "value": "${{ needs.deploy-backend.outputs.backend_url }}"
                  }
                }
              }
            }
          }'
      
      - name: Trigger Redeployment to Apply Environment Variables
        id: trigger_redeploy
        run: |
          echo "Triggering a new deployment to ensure all variables are applied..."
          curl -X POST "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/${{ secrets.CF_PAGES_PROJECT_NAME }}/deployments" \
          -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -H "Content-Type: application/json"

  # Job 3: éªŒè¯éƒ¨ç½²
  verify-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Install Tools
        run: |
          npm install -g wrangler
          command -v jq >/dev/null 2>&1 || (sudo apt-get update && sudo apt-get install -y jq)
      
      - name: Health Check Backend
        env:
          BACKEND_URL: ${{ needs.deploy-backend.outputs.backend_url }}
        run: |
          echo "Verifying backend at $BACKEND_URL with retries..."
          for i in $(seq 1 5); do
            curl -f "$BACKEND_URL" && break || sleep 10
          done
          
      # === ä¿®æ”¹ç‚¹ #2ï¼šå‰ç«¯éªŒè¯ï¼ˆAä¼˜å…ˆï¼šprodï¼›å¤±è´¥è‡ªåŠ¨ Bï¼špreviewï¼‰===
      - name: Verify frontend (prod-first, auto-fallback to preview)
        env:
          CF_PAGES_PROJECT_NAME: ${{ secrets.CF_PAGES_PROJECT_NAME }}
          FRONTEND_HEALTH_PATH: /index.html
        run: |
          set -e
          tries=24   # æœ€å¤šå°è¯• 24 æ¬¡
          wait=10    # æ¯æ¬¡ç­‰å¾… 10 ç§’
          ok=""
          
          # é¦–å…ˆå°è¯•ç”Ÿäº§åŸŸå
          URL="https://${CF_PAGES_PROJECT_NAME}.pages.dev"
          
          echo "ğŸ” éªŒè¯ç”Ÿäº§ç¯å¢ƒ $URL$FRONTEND_HEALTH_PATH (æœ€å¤š $tries æ¬¡å°è¯•)..."
          for i in $(seq 1 $tries); do
            code=$(curl -sS -L -o /dev/null -w "%{http_code}" "$URL$FRONTEND_HEALTH_PATH" || echo "000")
            if echo "$code" | grep -qE "^(20|30)"; then
              ok="yes"
              echo "âœ… ç”Ÿäº§ç¯å¢ƒå¥åº· (çŠ¶æ€ç : $code)"
              echo "VERIFIED_URL=$URL" >> $GITHUB_ENV
              break
            fi
            echo "å°è¯• $i è¿”å›çŠ¶æ€ç  $code; ${wait}ç§’åé‡è¯•..."
            sleep $wait
          done
          
          # å¦‚æœç”Ÿäº§ç¯å¢ƒå¤±è´¥ï¼Œå°è¯•é¢„è§ˆç¯å¢ƒ
          if [ -z "$ok" ]; then
            echo "âš ï¸ ç”Ÿäº§ç¯å¢ƒæ£€æŸ¥å¤±è´¥ï¼Œå°è¯•æœ€æ–°çš„é¢„è§ˆéƒ¨ç½²..."
            
            # è·å–æœ€æ–°çš„é¢„è§ˆURL
            PREVIEW_URL=$(npx wrangler pages deployments list --project-name "$CF_PAGES_PROJECT_NAME" --json \
              | jq -r '[.[] | select(.environment=="preview")] | sort_by(.created_on) | last | .url')
            
            if [ -n "$PREVIEW_URL" ]; then
              URL="$PREVIEW_URL"
              echo "ğŸ” éªŒè¯é¢„è§ˆç¯å¢ƒ $URL$FRONTEND_HEALTH_PATH..."
              
              for i in $(seq 1 $tries); do
                code=$(curl -sS -L -o /dev/null -w "%{http_code}" "$URL$FRONTEND_HEALTH_PATH" || echo "000")
                if echo "$code" | grep -qE "^(20|30)"; then
                  ok="yes"
                  echo "âœ… é¢„è§ˆç¯å¢ƒå¥åº· (çŠ¶æ€ç : $code)"
                  echo "VERIFIED_URL=$URL" >> $GITHUB_ENV
                  break
                fi
                echo "é¢„è§ˆå°è¯• $i è¿”å›çŠ¶æ€ç  $code; ${wait}ç§’åé‡è¯•..."
                sleep $wait
              done
            else
              echo "::error::æœªæ‰¾åˆ°é¢„è§ˆéƒ¨ç½²"
            fi
          fi
          
          if [ -z "$ok" ]; then
            echo "::error::å‰ç«¯å¥åº·æ£€æŸ¥å¤±è´¥ (Aæ–¹æ¡ˆå’ŒBæ–¹æ¡ˆéƒ½å¤±è´¥)"
            exit 1
          fi

      - name: Output verified URL
        if: ${{ success() }}
        run: |
          echo "âœ… éƒ¨ç½²éªŒè¯æˆåŠŸ!"
          echo "æœ€ç»ˆéªŒè¯çš„URL: ${{ env.VERIFIED_URL }}"
          